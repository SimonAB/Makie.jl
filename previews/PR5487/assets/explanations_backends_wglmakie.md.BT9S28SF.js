import{_ as s,c as a,o as n,aA as t}from"./chunks/framework.XgaOYGVC.js";const h=JSON.parse('{"title":"WGLMakie","description":"","frontmatter":{},"headers":[],"relativePath":"explanations/backends/wglmakie.md","filePath":"explanations/backends/wglmakie.md","lastUpdated":null}'),i={name:"explanations/backends/wglmakie.md"};function o(p,e,l,r,c,u){return n(),a("div",null,[...e[0]||(e[0]=[t(`<h1 id="WGLMakie" tabindex="-1">WGLMakie <a class="header-anchor" href="#WGLMakie" aria-label="Permalink to &quot;WGLMakie {#WGLMakie}&quot;">â€‹</a></h1><p><a href="https://github.com/MakieOrg/Makie.jl/tree/master/WGLMakie" target="_blank" rel="noreferrer">WGLMakie</a> is the web-based backend, which is mostly implemented in Julia right now. WGLMakie uses <a href="https://github.com/SimonDanisch/Bonito.jl" target="_blank" rel="noreferrer">Bonito</a> to generate the HTML and JavaScript for displaying the plots. On the JavaScript side, we use <a href="https://threejs.org/" target="_blank" rel="noreferrer">ThreeJS</a> and <a href="https://en.wikipedia.org/wiki/WebGL" target="_blank" rel="noreferrer">WebGL</a> to render the plots. Moving more of the implementation to JavaScript is currently the goal and will give us a better JavaScript API, and more interaction without a running Julia server.</p><div class="warning custom-block"><p class="custom-block-title">Warning</p><p>The WGLMakie documentation examples are not being built correctly as part of the move from Documenter to VitePress. For working examples of WGLMakie integration, see the <a href="https://simondanisch.github.io/Bonito.jl/stable/plotting.html" target="_blank" rel="noreferrer">Bonito plotting documentation</a> for Documenter integration, or <a href="https://bonitobook.org/website/examples/" target="_blank" rel="noreferrer">BonitoBook examples</a> where Bonito is used to generate a static site.</p></div><h2 id="Notebook-and-IDE-Environments" tabindex="-1">Notebook &amp; IDE Environments <a class="header-anchor" href="#Notebook-and-IDE-Environments" aria-label="Permalink to &quot;Notebook &amp;amp; IDE Environments {#Notebook-and-IDE-Environments}&quot;">â€‹</a></h2><div class="tip custom-block"><p class="custom-block-title">Tip</p><p>For the best WGLMakie notebook experience with full support for interactivity and static export, consider using <a href="https://bonitobook.org/" target="_blank" rel="noreferrer">BonitoBook</a> which is built on Bonito and provides seamless integration.</p></div><h3 id="IJulia" tabindex="-1">IJulia <a class="header-anchor" href="#IJulia" aria-label="Permalink to &quot;IJulia {#IJulia}&quot;">â€‹</a></h3><ul><li><p>Bonito now uses the IJulia connection, and therefore can be used even with complex proxy setups without any additional configuration.</p></li><li><p>Reloading the page isn&#39;t supported. If you reload, you need to re-execute all cells and make sure that <code>Page()</code> is executed first.</p></li></ul><h3 id="JupyterHub-/-JupyterLab-/-Binder" tabindex="-1">JupyterHub / JupyterLab / Binder <a class="header-anchor" href="#JupyterHub-/-JupyterLab-/-Binder" aria-label="Permalink to &quot;JupyterHub / JupyterLab / Binder {#JupyterHub-/-JupyterLab-/-Binder}&quot;">â€‹</a></h3><ul><li>WGLMakie should mostly work with a WebSocket connection. Bonito tries to <a href="https://github.com/SimonDanisch/Bonito.jl/blob/master/src/server-defaults.jl" target="_blank" rel="noreferrer">infer the proxy setup</a> needed to connect to the Julia process. On local JupyterLab instances, this should work without problem. On hosted instances one will likely need to have <a href="https://jupyter-server-proxy.readthedocs.io/en/latest/arbitrary-ports-hosts.html#with-jupyterhub" target="_blank" rel="noreferrer"><code>jupyter-server-proxy</code></a> installed, and then execute something like <code>Page(; listen_port=9091, proxy_url=&quot;&lt;jhub-instance&gt;.com/user/&lt;username&gt;/proxy/9091&quot;)</code>. Also see: <ul><li><p><a href="https://github.com/MakieOrg/Makie.jl/issues/2464" target="_blank" rel="noreferrer">issue #2464</a></p></li><li><p><a href="https://github.com/MakieOrg/Makie.jl/issues/2405" target="_blank" rel="noreferrer">issue #2405</a></p></li></ul></li></ul><h3 id="Pluto" tabindex="-1">Pluto <a class="header-anchor" href="#Pluto" aria-label="Permalink to &quot;Pluto {#Pluto}&quot;">â€‹</a></h3><ul><li><p>Still uses Bonito&#39;s WebSocket connection, so needs extra setup for remote servers.</p></li><li><p>Reloading the page isn&#39;t supported. If you reload, you need to re-execute all cells and make sure that <code>Page()</code> is executed first.</p></li><li><p>Static HTML export is not fully working yet. For static export, consider using <a href="https://bonitobook.org/" target="_blank" rel="noreferrer">BonitoBook</a>.</p></li></ul><h3 id="JuliaHub" tabindex="-1">JuliaHub <a class="header-anchor" href="#JuliaHub" aria-label="Permalink to &quot;JuliaHub {#JuliaHub}&quot;">â€‹</a></h3><ul><li><p>VS Code in the browser should work out of the box.</p></li><li><p>Pluto in JuliaHub still has a <a href="https://github.com/SimonDanisch/Bonito.jl/issues/140" target="_blank" rel="noreferrer">problem</a> with the WebSocket connection. You will see a plot, but interaction doesn&#39;t work.</p></li></ul><h3 id="Remote-Access" tabindex="-1">Remote Access <a class="header-anchor" href="#Remote-Access" aria-label="Permalink to &quot;Remote Access {#Remote-Access}&quot;">â€‹</a></h3><p>Locally, WGLMakie should just work out of the box for Pluto/IJulia. However, if you&#39;re accessing the notebook from another PC, you must configure the server:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">begin</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Bonito</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    some_forwarded_port </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8080</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    Page</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(listen_url</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;0.0.0.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, listen_port</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">some_forwarded_port)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`\`\`\`</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">You can also specify a proxy URL if you have a more complex proxy setup.</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">For more advanced setups, consult the \`?Page\` docs and \`Bonito.configure_server!\`.</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">See the [headless](@ref &quot;Using WGLMakie&quot;) documentation for more about setting up the Bonito server and port forwarding.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">### WebGL Compatibility</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Some browsers may have only WebGL 1.0, or need extra steps to enable WebGL, but in general, all modern browsers on [mobile and desktop should support WebGL 2.0](https://www.lambdatest.com/web-technologies/webgl2).</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Safari users may need to [enable](https://discussions.apple.com/thread/8655829) WebGL, though.</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">If you end up stuck on WebGL 1.0, the main missing feature will be \`volume\` &amp; \`contour(volume)\`.</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">## Activation and screen config</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Activate the backend by calling \`WGLMakie.activate!()\` with the following options:</span></span></code></pre></div><p>@docs WGLMakie.activate!</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>### Loading Spinner</span></span>
<span class="line"><span></span></span>
<span class="line"><span>WGLMakie shows a loading spinner while the scene is being initialized. By default, a \`CircleSpinner\` is displayed, but you can customize or remove it.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#### Removing the Spinner</span></span>
<span class="line"><span></span></span>
<span class="line"><span>To remove the spinner entirely, pass \`nothing\`:</span></span></code></pre></div><p>julia WGLMakie.activate!(; spinner=nothing)</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>#### Styling the Default Spinner</span></span>
<span class="line"><span></span></span>
<span class="line"><span>The default \`CircleSpinner\` accepts several styling options:</span></span></code></pre></div><p>julia using WGLMakie</p><h1 id="Customize-the-spinner&#39;s-appearance" tabindex="-1">Customize the spinner&#39;s appearance <a class="header-anchor" href="#Customize-the-spinner&#39;s-appearance" aria-label="Permalink to &quot;Customize the spinner&amp;#39;s appearance {#Customize-the-spinner&#39;s-appearance}&quot;">â€‹</a></h1><p>spinner = WGLMakie.CircleSpinner(; size=100, # diameter in pixels stroke=10, # border width in pixels color=&quot;red&quot;, # color of the spinning part background_color=&quot;rgba(1, 0, 0, 0.9)&quot;, # color of the background circle duration=1 # rotation speed in seconds ) WGLMakie.activate!(; spinner=spinner)</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>#### Using a Custom Spinner</span></span>
<span class="line"><span></span></span>
<span class="line"><span>To create a custom spinner, define a struct and implement \`Bonito.jsrender\`. This pattern ensures each scene gets its own spinner instance (avoiding shared DOM issues):</span></span></code></pre></div><p>julia using WGLMakie using Bonito</p><h1 id="Define-a-custom-spinner-struct" tabindex="-1">Define a custom spinner struct <a class="header-anchor" href="#Define-a-custom-spinner-struct" aria-label="Permalink to &quot;Define a custom spinner struct {#Define-a-custom-spinner-struct}&quot;">â€‹</a></h1><p>struct TextSpinner message::String background::String end</p><h1 id="Implement-jsrender-to-create-fresh-DOM-on-each-render" tabindex="-1">Implement jsrender to create fresh DOM on each render <a class="header-anchor" href="#Implement-jsrender-to-create-fresh-DOM-on-each-render" aria-label="Permalink to &quot;Implement jsrender to create fresh DOM on each render {#Implement-jsrender-to-create-fresh-DOM-on-each-render}&quot;">â€‹</a></h1><p>function Bonito.jsrender(session::Bonito.Session, spinner::TextSpinner) container_styles = Bonito.Styles( Bonito.CSS( &quot;.wglmakie-spinner&quot;, &quot;position&quot; =&gt; &quot;absolute&quot;, &quot;top&quot; =&gt; &quot;50%&quot;, &quot;left&quot; =&gt; &quot;50%&quot;, &quot;transform&quot; =&gt; &quot;translate(-50%, -50%)&quot;, &quot;background&quot; =&gt; spinner.background, &quot;padding&quot; =&gt; &quot;20px&quot;, &quot;border-radius&quot; =&gt; &quot;8px&quot;, &quot;z-index&quot; =&gt; &quot;1000&quot;, &quot;color&quot; =&gt; &quot;white&quot;, &quot;font-size&quot; =&gt; &quot;14px&quot;, ) ) return Bonito.jsrender(session, Bonito.DOM.div(container_styles, spinner.message; class=&quot;wglmakie-spinner&quot;)) end</p><h1 id="Use-the-custom-spinner" tabindex="-1">Use the custom spinner <a class="header-anchor" href="#Use-the-custom-spinner" aria-label="Permalink to &quot;Use the custom spinner {#Use-the-custom-spinner}&quot;">â€‹</a></h1><p>custom_spinner = TextSpinner(&quot;Loading visualization...&quot;, &quot;rgba(0, 0, 0, 0.7)&quot;) WGLMakie.activate!(; spinner=custom_spinner)</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>Note: The \`wglmakie-spinner\` class is required as WGLMakie uses it to find and remove the spinner once the scene is fully loaded.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>### HTML Native Widgets</span></span>
<span class="line"><span></span></span>
<span class="line"><span>WGLMakie supports rendering Makie&#39;s interactive widgets (Slider, Button, Menu, Textbox, Checkbox, Toggle) as native HTML elements instead of canvas-based graphics. This can be enabled with:</span></span></code></pre></div><p>julia WGLMakie.activate!(; use_html_widgets = true)</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>#### Implementation</span></span>
<span class="line"><span></span></span>
<span class="line"><span>- Replaces Makie Block widgets with native HTML \`&lt;input&gt;\`, \`&lt;button&gt;\`, \`&lt;select&gt;\`, etc. elements with Bonito</span></span>
<span class="line"><span>- HTML widgets are positioned absolutely over the canvas to match the layout position of the Makie widget</span></span>
<span class="line"><span>- Bidirectional synchronization between the Makie widget and HTML elements</span></span>
<span class="line"><span>- We tried to match most styling attributes, but exact look is not guaranteed. For now, it also doesn&#39;t support updating styling attributes.</span></span>
<span class="line"><span>- We still create the whole Makie widget, but don&#39;t render it; instead, we sync it with the HTML element</span></span>
<span class="line"><span></span></span>
<span class="line"><span>**Pros:**</span></span>
<span class="line"><span>- Native browser controls provide better performance (e.g., for Makie native widgets, just a hover takes quite a bit of data round-tripping between the browser and Julia) and are independent of the Julia event loop</span></span>
<span class="line"><span>- Proper text input support (cursor positioning, text selection, copy/paste)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>**Cons:**</span></span>
<span class="line"><span>- Screenshot/export functionality needs special handling to capture HTML elements</span></span>
<span class="line"><span>- Some advanced Makie styling options may not translate to HTML</span></span>
<span class="line"><span>- With the current implementation, we still have the overhead of creating the plots for the native widgets (should be a minimal one-time cost though)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>**Example:**</span></span></code></pre></div><p>julia using WGLMakie WGLMakie.activate!(; use_html_widgets = true)</p><p>fig = Figure() ax = Axis(fig[1, 1]) sl = Makie.Slider(fig[2, 1], range = 0:0.1:10, startvalue = 5, tellwidth=false) btn = Makie.Button(fig[3, 1], label = &quot;Click me&quot;, tellwidth=false) x = 0:10 lines!(ax, x, map(y -&gt; sin.(y .* x), sl.value)) fig # Will get rendered with HTML widgets</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>You can also use this locally in a Bonito app:</span></span></code></pre></div><p>julia App() do DOM.div(WGLMakie.WithConfig(fig; use_html_widget=true)) end</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>## Output</span></span>
<span class="line"><span></span></span>
<span class="line"><span>You can use Bonito and WGLMakie in Pluto, IJulia, Webpages and Documenter to create interactive apps and dashboards, serve them on live webpages, or export them to static HTML.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>This tutorial will run through the different modes and what kind of limitations to expect.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>### Page</span></span>
<span class="line"><span></span></span>
<span class="line"><span>\`Page()\` can be used to reset the Bonito state needed for multipage output, as is the case for \`Documenter\` or the various notebooks (IJulia/Pluto/etc).</span></span>
<span class="line"><span>Previously, it was necessary to always insert and display the \`Page\` call in notebooks, but now the call to \`Page()\` is optional and doesn&#39;t need to be displayed.</span></span>
<span class="line"><span>What it does is purely reset the state for a new multi-page output, which is usually the case for \`Documenter\`, which creates multiple pages in one Julia session, or you can use it to reset the state in notebooks, e.g. after a page reload.</span></span>
<span class="line"><span>\`Page(exportable=true, offline=true)\` can be used to force inlining all data &amp; js dependencies, so that everything can be loaded in a single HTML object without a running Julia process. The defaults should already be chosen this way for e.g. Documenter, so this should mostly be used for e.g. \`Pluto\` offline export (which is currently not fully supported, but should be soon).</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Here is an example of how to use this in Franklin:</span></span></code></pre></div><p>@example wglmakie using WGLMakie using Bonito, Markdown Page() # for Franklin, you still need to configure WGLMakie.activate!() Makie.inline!(true) # Make sure to inline plots into Documenter output! scatter(1:4, color=1:4)</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>As you can see, the output is completely static, because we don&#39;t have a running Julia server, as would be the case with e.g. Pluto.</span></span>
<span class="line"><span>To make the plot interactive, we will need to write more parts of WGLMakie in JS, which is an ongoing effort.</span></span>
<span class="line"><span>As you can see, the interactivity already keeps working for 3D:</span></span></code></pre></div><p>@example wglmakie N = 60 function xy_data(x, y) r = sqrt(x^2 + y^2) r == 0.0 ? 1f0 : (sin(r)/r) end l = range(-10, stop = 10, length = N) z = Float32[xy_data(x, y) for x in l, y in l] surface( -1..1, -1..1, z, colormap = :Spectral )</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>There are a couple of ways to keep interacting with Plots in a static export.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>## Record a statemap</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Bonito allows recording a statemap for all widgets that satisfy the following interface:</span></span></code></pre></div><p>julia</p><h1 id="must-be-true-to-be-found-inside-the-DOM" tabindex="-1">must be true to be found inside the DOM <a class="header-anchor" href="#must-be-true-to-be-found-inside-the-DOM" aria-label="Permalink to &quot;must be true to be found inside the DOM {#must-be-true-to-be-found-inside-the-DOM}&quot;">â€‹</a></h1><p>is_widget(x) = true</p><h1 id="Updating-the-widget-isn&#39;t-dependent-on-any-other-state-only-thing-supported-right-now" tabindex="-1">Updating the widget isn&#39;t dependent on any other state (only thing supported right now) <a class="header-anchor" href="#Updating-the-widget-isn&#39;t-dependent-on-any-other-state-only-thing-supported-right-now" aria-label="Permalink to &quot;Updating the widget isn&amp;#39;t dependent on any other state (only thing supported right now) {#Updating-the-widget-isn&#39;t-dependent-on-any-other-state-only-thing-supported-right-now}&quot;">â€‹</a></h1><p>is_independant(x) = true</p><h1 id="The-values-a-widget-can-iterate" tabindex="-1">The values a widget can iterate <a class="header-anchor" href="#The-values-a-widget-can-iterate" aria-label="Permalink to &quot;The values a widget can iterate {#The-values-a-widget-can-iterate}&quot;">â€‹</a></h1><p>function value_range end</p><h1 id="updating-the-widget-with-a-certain-value-usually-an-observable" tabindex="-1">updating the widget with a certain value (usually an observable) <a class="header-anchor" href="#updating-the-widget-with-a-certain-value-usually-an-observable" aria-label="Permalink to &quot;updating the widget with a certain value (usually an observable) {#updating-the-widget-with-a-certain-value-usually-an-observable}&quot;">â€‹</a></h1><p>function update_value!(x, value) end</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>Currently, only sliders overload the interface:</span></span></code></pre></div><p>@example wglmakie using Observables</p><p>App() do session::Session n = 10 index_slider = Slider(1:n) volume = rand(n, n, n) slice = map(index_slider) do idx return volume[:, :, idx] end fig = Figure() ax, cplot = contour(fig[1, 1], volume) rectplot = linesegments!(ax, Rect(-1, -1, 12, 12), linewidth=2, color=:red) on(index_slider) do idx translate!(rectplot, 0,0,idx) end heatmap(fig[1, 2], slice) slider = DOM.div(&quot;z-index: &quot;, index_slider, index_slider.value) return Bonito.record_states(session, DOM.div(slider, fig)) end</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>## Execute JavaScript directly</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Bonito makes it easy to build whole HTML and JS applications.</span></span>
<span class="line"><span>You can, for example, directly register JavaScript functions that get run on change.</span></span></code></pre></div><p>@example wglmakie using Bonito</p><p>App() do session::Session s1 = Slider(1:100) slider_val = DOM.p(s1[]) # initialize with current value # call the <code>on_update</code> function whenever s1.value changes in JS: onjs(session, s1.value, js&quot;&quot;&quot;function on_update(new_value) { //interpolating of DOM nodes and other Julia values work mostly as expected: const p_element = $(Expr(:incomplete, Base.Meta.ParseError(&quot;ParseError:\\n# Error @ none:1:8\\n(slider\\n# â”” â”€â”€ Expected <code>)</code> or <code>,</code>&quot;, Base.JuliaSyntax.ParseError(Base.JuliaSyntax.SourceFile(&quot;(slider&quot;, 0, &quot;none&quot;, 1, [1, 8]), Base.JuliaSyntax.Diagnostic[Base.JuliaSyntax.Diagnostic(8, 7, :error, &quot;Expected <code>)</code> or <code>,</code>&quot;)], :other))))_val) p_element.innerText = new_value } &quot;&quot;&quot;)</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>return DOM.div(&quot;slider 1: &quot;, s1, slider_val)</span></span></code></pre></div><p>end</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>One can also interpolate plots into JS and update those via JS.</span></span>
<span class="line"><span>The problem is that there isn&#39;t a great interface yet.</span></span>
<span class="line"><span>The returned object is directly a THREE object, with all plot attributes converted into JavaScript types.</span></span>
<span class="line"><span>The good news is that all attributes should be in either \`three_scene.material.uniforms\` or \`three_scene.geometry.attributes\`.</span></span>
<span class="line"><span>Going forward, we should create an API in WGLMakie that makes it as easy as in Julia: \`plot.attribute = value\`.</span></span>
<span class="line"><span>But while this isn&#39;t in place, logging the returned object makes it pretty easy to figure out what to doâ€”the JS console + logging is amazing and makes it very easy to play around with the object once logged.</span></span></code></pre></div><p>@example wglmakie using Bonito: on_document_load using WGLMakie</p><p>App() do session::Session s1 = Slider(1:100) slider_val = DOM.p(s1[]) # initialize with current value</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>fig, ax, splot = scatter(1:4)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># With on_document_load one can run JS after everything got loaded.</span></span>
<span class="line"><span># This is an alternative to \`evaljs\`, which we can&#39;t use here,</span></span>
<span class="line"><span># since it gets run asap, which means the plots won&#39;t be found yet.</span></span>
<span class="line"><span>on_document_load(session, js&quot;&quot;&quot;</span></span>
<span class="line"><span>    // you get a promise for an array of plots, when interpolating into JS:</span></span>
<span class="line"><span>    $(splot).then(plots=&gt;{</span></span>
<span class="line"><span>        // just one plot for atomics like scatter, but for recipes it can be multiple plots</span></span>
<span class="line"><span>        const scatter_plot = plots[0]</span></span>
<span class="line"><span>        // open the console with Ctrl+Shift+I to inspect the values</span></span>
<span class="line"><span>        // tip - you can right click on the log and store the actual variable as a global, and directly interact with it to change the plot.</span></span>
<span class="line"><span>        console.log(scatter_plot)</span></span>
<span class="line"><span>        console.log(scatter_plot.material.uniforms)</span></span>
<span class="line"><span>        console.log(scatter_plot.geometry.attributes)</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>&quot;&quot;&quot;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># with the above, we can find out that the positions are stored in \`offset\`</span></span>
<span class="line"><span># (*sigh*, this is because threejs special cases \`position\` attributes so it can&#39;t be used)</span></span>
<span class="line"><span># Now, let&#39;s go and change them when using the slider :)</span></span>
<span class="line"><span>onjs(session, s1.value, js&quot;&quot;&quot;function on_update(new_value) {</span></span>
<span class="line"><span>    $(splot).then(plots=&gt;{</span></span>
<span class="line"><span>        const scatter_plot = plots[0]</span></span>
<span class="line"><span>        // change first point x + y value</span></span>
<span class="line"><span>        scatter_plot.geometry.attributes.pos.array[0] = (new_value/100) * 4</span></span>
<span class="line"><span>        scatter_plot.geometry.attributes.pos.array[1] = (new_value/100) * 4</span></span>
<span class="line"><span>        // this always needs to be set on geometry attributes after an update</span></span>
<span class="line"><span>        scatter_plot.geometry.attributes.pos.needsUpdate = true</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>&quot;&quot;&quot;)</span></span>
<span class="line"><span># and for good measure, add a slider to change the color:</span></span>
<span class="line"><span>color_slider = Slider(LinRange(0, 1, 100))</span></span>
<span class="line"><span>onjs(session, color_slider.value, js&quot;&quot;&quot;function on_update(hue) {</span></span>
<span class="line"><span>    $(splot).then(plots=&gt;{</span></span>
<span class="line"><span>        const scatter_plot = plots[0]</span></span>
<span class="line"><span>        const color = new THREE.Color()</span></span>
<span class="line"><span>        color.setHSL(hue, 1.0, 0.5)</span></span>
<span class="line"><span>        scatter_plot.material.uniforms.color.value.x = color.r</span></span>
<span class="line"><span>        scatter_plot.material.uniforms.color.value.y = color.g</span></span>
<span class="line"><span>        scatter_plot.material.uniforms.color.value.z = color.b</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>}&quot;&quot;&quot;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>markersize = Slider(1:100)</span></span>
<span class="line"><span>onjs(session, markersize.value, js&quot;&quot;&quot;function on_update(size) {</span></span>
<span class="line"><span>    $(splot).then(plots=&gt;{</span></span>
<span class="line"><span>        const scatter_plot = plots[0]</span></span>
<span class="line"><span>        scatter_plot.material.uniforms.markersize.value.x = size</span></span>
<span class="line"><span>        scatter_plot.material.uniforms.markersize.value.y = size</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>}&quot;&quot;&quot;)</span></span>
<span class="line"><span>return DOM.div(s1, color_slider, markersize, fig)</span></span></code></pre></div><p>end</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>This summarizes the current state of interactivity with WGLMakie inside static pages.</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>## Offline Tooltip</span></span>
<span class="line"><span></span></span>
<span class="line"><span>\`Makie.DataInspector\` works just fine with WGLMakie, but it requires a running Julia process to show and update the tooltip.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>There is also a way to show a tooltip in JavaScript directly, which needs to be inserted into the HTML DOM.</span></span>
<span class="line"><span>This means, we actually need to use \`Bonito.App\` to return a \`DOM\` object:</span></span></code></pre></div><p>@example wglmakie App() do session f, ax, pl = scatter(1:4, markersize=100, color=Float32[0.3, 0.4, 0.5, 0.6]) custom_info = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] on_click_callback = js&quot;&quot;&quot;(plot, index) =&gt; { // the plot object is currently just the raw THREEJS mesh console.log(plot) // Which can be used to extract e.g. position or color: const {pos, color} = plot.geometry.attributes console.log(pos) console.log(color) const x = pos.array[index_2] // everything is a flat array in JS const y = pos.array[index_2+1] const c = Math.round(color.array[index] * 10) / 10 // rounding to a digit in JS const custom = $(Expr(:incomplete, Base.Meta.ParseError(&quot;ParseError:\\n# Error @ none:1:8\\n(custom\\n# â”” â”€â”€ Expected <code>)</code> or <code>,</code>&quot;, Base.JuliaSyntax.ParseError(Base.JuliaSyntax.SourceFile(&quot;(custom&quot;, 0, &quot;none&quot;, 1, [1, 8]), Base.JuliaSyntax.Diagnostic[Base.JuliaSyntax.Diagnostic(8, 7, :error, &quot;Expected <code>)</code> or <code>,</code>&quot;)], :other))))_info)[index] // return either a string, or an HTMLNode: return &quot;Point: &lt;&quot; + x + &quot;, &quot; + y + &quot;&gt;, value: &quot; + c + &quot; custom: &quot; + custom } &quot;&quot;&quot;</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># ToolTip(figurelike, js_callback; plots=plots_you_want_to_hover)</span></span>
<span class="line"><span>tooltip = WGLMakie.ToolTip(f, on_click_callback; plots=pl)</span></span>
<span class="line"><span>return DOM.div(f, tooltip)</span></span></code></pre></div><p>end</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>## Styling</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Bonito allows loading arbitrary CSS, and \`DOM.xxx\` wraps all existing HTML tags.</span></span>
<span class="line"><span>So any CSS file can be used, e.g. even libraries like [Tailwind](https://tailwindcss.com/) with \`Asset\`:</span></span></code></pre></div><p>julia TailwindCSS = Bonito.Asset(&quot;/path/to/tailwind.min.css&quot;)</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>Bonito also offers the \`Styles\` type, which allows to define whole stylesheets and assign them to any DOM object.</span></span>
<span class="line"><span>That&#39;s how Bonito creates styleable components:</span></span></code></pre></div><p>julia Rows(args...) = DOM.div(args..., style=Styles( &quot;display&quot; =&gt; &quot;grid&quot;, &quot;grid-template-rows&quot; =&gt; &quot;fr&quot;, &quot;grid-template-columns&quot; =&gt; &quot;repeat(length(args), fr)&quot;, ))</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>This Style object will only be inserted one time into the DOM in one Session, and subsequent uses will just give the div the same class.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Note, that Bonito already defines something like the above \`Rows\`:</span></span></code></pre></div><p>@example wglmakie using Colors using Bonito</p><p>App() do session::Session hue_slider = Slider(0:360) color_swatch = DOM.div(class=&quot;h-6 w-6 p-2 m-2 rounded shadow&quot;) onjs(session, hue_slider.value, js&quot;&quot;&quot;function (hue){ $(Expr(:incomplete, Base.Meta.ParseError(&quot;ParseError:\\n# Error @ none:1:7\\n(color\\n# â”” â”€â”€ Expected <code>)</code> or <code>,</code>&quot;, Base.JuliaSyntax.ParseError(Base.JuliaSyntax.SourceFile(&quot;(color&quot;, 0, &quot;none&quot;, 1, [1, 7]), Base.JuliaSyntax.Diagnostic[Base.JuliaSyntax.Diagnostic(7, 6, :error, &quot;Expected <code>)</code> or <code>,</code>&quot;)], :other))))_swatch).style.backgroundColor = &quot;hsl(&quot; + hue + &quot;,60%,50%)&quot; }&quot;&quot;&quot;) return Row(hue_slider, color_swatch) end</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>Bonito also offers a styleable Card component:</span></span></code></pre></div><p>@example wglmakie using Markdown</p><p>App() do session::Session # We can now use this wherever we want: fig = Figure(size=(300, 300)) contour(fig[1,1], rand(4,4)) card = Card(Grid( Centered(DOM.h1(&quot;Hello&quot;); style=Styles(&quot;grid-column&quot; =&gt; &quot;1 / 3&quot;)), StylableSlider(1:100; style=Styles(&quot;grid-column&quot; =&gt; &quot;1 / 3&quot;)), DOM.img(src=&quot;<a href="https://julialang.org/assets/infra/logo.svg&amp;quot;" target="_blank" rel="noreferrer">https://julialang.org/assets/infra/logo.svg&quot;</a>), fig; columns=&quot;1fr 1fr&quot;, justify_items=&quot;stretch&quot; )) # Markdown creates a DOM as well, and you can interpolate # arbitrary jsrender&#39;able elements in there: return DOM.div(card) end</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>Hopefully, over time there will be helper libraries with lots of stylised elements like the above, to make flashy dashboards with Bonito + WGLMakie.</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Export</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Documenter just renders the plots + Page as HTML, so if you want to inline WGLMakie/Bonito objects into your own page,</span></span>
<span class="line"><span>one can just use something like this:</span></span></code></pre></div><p>julia using WGLMakie, Bonito, FileIO WGLMakie.activate!()</p><p>open(&quot;index.html&quot;, &quot;w&quot;) do io println(io, &quot;&quot;&quot; &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &quot;&quot;&quot;) Page(exportable=true, offline=true) # Then, you can just inline plots or whatever you want ðŸ˜ƒ # Of course it would make more sense to put this into a single app app = App() do C(x;kw...) = Card(x; height=&quot;fit-content&quot;, width=&quot;fit-content&quot;, kw...) figure = (; size=(300, 300)) f1 = scatter(1:4; figure) f2 = mesh(load(assetpath(&quot;brain.stl&quot;)); figure) C(DOM.div( Bonito.StylableSlider(1:100), Row(C(f1), C(f2)) ); padding=&quot;30px&quot;, margin=&quot;15px&quot;) end show(io, MIME&quot;text/html&quot;(), app) # or anything else from Bonito, or that can be displayed as html: println(io, &quot;&quot;&quot; &lt;/body&gt; &lt;/html&gt; &quot;&quot;&quot;) end</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>You can also simply export a plot into a self contained HTML file:</span></span></code></pre></div><p>julia using Bonito export_static(&quot;plot.html&quot;, App(scatter(rand(Point2f, 100)))) \`\`\`</p>`,84)])])}const g=s(i,[["render",o]]);export{h as __pageData,g as default};
